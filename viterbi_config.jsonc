{
  "io": {
    // Dossier contenant les .jsonl (1 fichier = 1 morceau)
    "jsonl_dir": "./test_input_folder",

    // Dossier de sortie pour écrire les prédictions .jsonl (même nom de fichier)
    "out_pred_dir": "./test_output_folder",

    // Limite de fichiers traités (null = tous)
    "limit_files": 50
  },

  "search": {
    // Frette maximale autorisée pour générer les positions (string,fret)
    "max_fret": 20,

    // Pour chaque pitch, on garde les K meilleures positions (string,fret) selon un heuristique
    // (plus grand => meilleur mais plus lent)
    "per_pitch_k": 4,

    // Pour chaque event (accord), on garde les K meilleurs voicings générés (plus grand => meilleur mais plus lent)
    "chord_k": 50,

    // Beam size du Viterbi (nombre de chemins conservés à chaque pas)
    // (plus grand => meilleur mais plus lent)
    "beam_size": 30
  },

  "local_cost": {
    // Poids de pénalité du "span" de l'accord (écartement main) : max(fretted) - min(fretted)
    "w_span": 0.6,

    // Pénalité des frettes hautes : somme(max(0, fret - high_fret_threshold))
    // Multipliée par w_high
    "w_high": 0.25,

    // Seuil à partir duquel on commence à pénaliser les frettes hautes (ex: au-dessus de la 12e)
    "high_fret_threshold": 17,

    // Bonus (négatif) par corde à vide dans l'accord (plus négatif => préfère davantage les open strings)
    // Exemple : -0.05 => léger bonus
    "w_open_bonus": 0.05,

    // Pénalité liée à l'étendue des cordes de l'accord (max(string)-min(string))
    // Encourage des formes "compactes" sur les cordes.
    "w_string_range": 0.2
  },

  "string_discontinuity": {
    // Pénalise les "trous" de cordes, ex: cordes {5,4,2,1} => trou corde 3
    // holes = (maxS - minS + 1) - |S|
    // Plus grand => évite davantage les accords injouables au médiator
    "w_holes": 10,

    // Pénalise les grands sauts entre cordes adjacentes de l'accord
    // max_gap = max(diff(sorted(strings))) ; pénalité sur max(0, max_gap-1)
    "w_gap": 0.6,

    // Pénalise les accords "en blocs" (plusieurs groupes contigus de cordes)
    // blocks = nombre de groupes contigus; pénalité sur max(0, blocks-1)
    "w_blocks": 10
  },

  "transition_cost": {
    // Poids principal du saut d'ancre (anchor jump)
    // anchor = min fret fretté (ignore open) ou 0 si tout open/rest
    "w_jump": 0.8,

    // Exposant non-linéaire pour le jump : coût += w_jump * (jump ** jump_power)
    // Plus grand => gros jumps très pénalisés
    "jump_power": 1.1,

    // Seuil de jump à partir duquel on ajoute une pénalité fixe (simule "reset de main")
    "jump_threshold": 7.0,

    // Pénalité fixe ajoutée si jump > jump_threshold
    "jump_threshold_penalty": 6.0,

    // Poids du déplacement basé sur la position moyenne (avgpos) des frettes frettées
    // coût += w_avg_jump * (avg_jump ** avg_jump_power)
    "w_avg_jump": 0.6,

    // Exposant sur avg_jump (non linéaire)
    "avg_jump_power": 1.3,

    // Pénalise le changement de span entre deux events (évite de "reformer" la main)
    "w_span_change": 0.25,

    // Pénalise le déplacement du "centre de cordes" de l'accord
    // center = mean(strings) ; utile pour garder une zone de cordes cohérente
    "w_string_center": 3,

    // Si jump <= close_jump_threshold, on applique un bonus (négatif) pour encourager la stabilité
    "close_jump_threshold": 4.0,

    // Bonus ajouté si jump est petit (valeur négative recommandée)
    "close_jump_bonus": -1.2,

    // (Optionnel) coût quand on passe d'un REST -> NOTES (attaque après silence)
    "rest_enter_penalty": 0.0,

    // (Optionnel) coût quand on passe de NOTES -> REST (relâchement)
    "rest_exit_penalty": 0.0
  }
}